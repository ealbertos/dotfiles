'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/**
 * Wraps data in an Ok.
 * @param data The success payload
 *
 * ```javascript
 * ok(1)
 * ```
 */
const ok = (data) => new OkResult(data);
/**
 * Wraps a message in an Error.
 * @param data The success payload
 *
 * ```javascript
 * error("not found")
 * ```
 */
const error = (message) => new ErrorResult(message);
/**
 * Type guard to check if a Result is Ok
 * @param result - The result to check
 *
 * ```javascript
 * const result = ok(1);
 *
 * if (isOk(result)) {
 *   result.ok // exists
 * }
 * ```
 */
function isOk(result) {
    return "ok" in result;
}
/**
 * Type guard to check if a Result is an Error
 * @param result - The result to check
 *
 * ```javascript
 * const result = error("not found");
 *
 * if (isError(result)) {
 *   result.error // exists
 * }
 * ```
 */
function isError(result) {
    return "error" in result;
}
/**
 * Type guard to check if an object is a Result.
 * @param result - The object to check
 *
 * ```javascript
 * const result = ;
 *
 * isResult(error("not found")) // true
 * ```
 */
const isResult = (result) => isOk(result) || isError(result);
/* tslint:disable:function-name */
/**
 * Represents the result of a successful operation.
 * Create one with Result.ok(data)
 * Fantasy-land Functor
 */
class OkResult {
    constructor(ok) {
        this.ok = ok;
    }
    toString() {
        return `{ok: ${this.ok}}`;
    }
    map(f) {
        return ok(f(this.ok));
    }
    "fantasy-land/map"(f) {
        return this.map(f);
    }
}
/**
 * Represents the result of an unsuccessful operation.
 * Create one with Result.ok(data)
 * Fantasy-land Functor
 */
class ErrorResult {
    constructor(error) {
        this.error = error;
    }
    toString() {
        return `{error: ${this.error}}`;
    }
    map(_f) {
        return this;
    }
    "fantasy-land/map"(f) {
        return this.map(f);
    }
}

// Solves an error with returning ResultP from an async function.
// tslint:disable-next-line:variable-name
const ResultP = Promise;
/**
 * Chains together async operations that may succeed or fail
 *
 * Takes a Result and a mapping function.
 * If the result is an Ok, applies the function to the data.
 * If the result is an Error, passes the Result through unchanged.
 *
 * @param f - the function to run on the ok data
 * @param result - The result to match against
 * @returns - The Result from function f or the Error
 *
 * ```javascript
 * pipeA
 *   (fetchUser())
 *   (okChainAsync(user => fetchComments(user.id)))
 *   (okDo(comments => console.log('total comments:', comments.length))
 *   .value
 * ```
 */
function okChainAsync(f) {
    return function (result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isError(result)) {
                return result;
            }
            return f(result.ok);
        });
    };
}
/**
 * Chains together async operations that may succeed or fail
 *
 * Takes a Result and a mapping function.
 * If the result is an Error, applies the function to the data and returns the new promise-wrapped result.
 * If the result is an Ok, passes the Result through unchanged.
 *
 * @param f - the function to run on the error message
 * @param result - The result to match against
 * @returns - The Result from function f or the Ok result
 *
 * ```javascript
 * const fetchData = () => fetch("https://example.com/data");
 * pipeA
 *   (getCachedData)
 *   (errorRescueAsync(fetchData))
 *   (okThen(transformData))
 *   .value
 * ```
 */
function errorRescueAsync(f) {
    return function (result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isOk(result)) {
                return result;
            }
            return f(result.error);
        });
    };
}
/**
 * Runs a function for side effects on the payload, only if the result is Ok.
 *
 * @param f - the async function to run on the ok data
 * @param result - The result to match against
 * @returns A promise of the the original result
 *
 * ```javascript
 * pipeA(
 *   (fetchData)
 *   // Saves to cache, and awaits completion before moving on.
 *   (okDoAsync(saveToCache))
 *   (okThen(transformData))
 * ```
 */
function okDoAsync(f) {
    return function (result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isOk(result)) {
                yield f(result.ok);
            }
            return result;
        });
    };
}
/**
 * Runs a function for side effects on the payload, only if the result is Error. Waits for the side effect to complete before returning.
 *
 * @param f - the function to run on the error message
 * @param result - The result to match against
 * @returns a promise of the original Result
 *
 * ```javascript
 * pipeA(
 *   (fetchData)
 *   // Logs an error, and awaits completion before moving on.
 *   (errorDoAsync(logError))
 *   (okThen(transformData))
 * ```
 */
function errorDoAsync(f) {
    return function (result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isError(result)) {
                yield f(result.error);
            }
            return result;
        });
    };
}
/**
 * Awaits a promise, and returns a result based on the outcome
 *
 * Note that the Error case isn't typesafe, since promises don't have an
 * error type, just a success one. It's probably a good idea to use a
 * `errorThen` or `errorReplace` to handle errors and soon as possible.
 *
 * @param promise
 * @returns Ok if the promise resolved, Error if it was rejected.
 *
 * ```javascript
 * pipeA(
 *   (promiseToResult(fetch("http://example.com/data")))
 *   (errorThen(handleError))
 *   (okThen(transformData))
 * ```
 */
function promiseToResult(promise) {
    return promise.then(ok).catch(error);
}
/**
 * Converts a function that returns a promise to one that always resolved to a Result
 *
 * Note that the Error case isn't typesafe, since promises don't have an
 * error type, just a success one. It's probably a good idea to use a
 * `errorThen` or `errorReplace` to handle errors and soon as possible.
 *
 * @param f A function that returns a promise
 * @returns a function that returns a promise that always resolves to a Result
 *
 * ```javascript
 * const writeFile = resultify(promisify(fs.writeFile));
 *
 * pipeA(
 *   (writeFile("path/to/file"))
 *   (errorThen(handleError))
 *   (okThen(transformFileData))
 * )
 * ```
 */
function resultify(f) {
    return function (...args) {
        return promiseToResult(f(...args));
    };
}

/**
 * Transforms a successful result, and passes through a failed result.
 *
 * Takes a mapping function, then a result.
 * If the result is an Ok, applies the function to the data.
 * If the result is an Error, passes the Result through unchanged.
 *
 * Wraps the output of the function in an Ok.
 *
 * @param f - the function to run on the ok data
 * @param result - The result to match against
 *
 * ```javascript
 * function add1(n) {
 *   return n + 1
 * }
 *
 * okThen(add1)(ok(1)) // ok(2)
 * okThen(add1)(error("bad")) // error("bad")
 * okThen(add1)(ok(-1)) // ok(0)
 * ```
 */
function okThen(f) {
    return function (result) {
        if (isError(result)) {
            return result;
        }
        return ok(f(result.ok));
    };
}
/**
 * Transforms a failed result, and passes through a successful result.
 *
 * Takes a mapping function, then a result.
 * If the result is an Error, applies the function to the data.
 * If the result is an Ok, passes the Result through unchanged.
 *
 * Wraps the output of the function in an Error.
 *
 * @param f - the function to run on the error data
 * @param result - The result to match against
 * @returns - The Result from function f or the Ok result
 *
 * ```javascript
 * const normalizeErrorCase = errorThen(message =>
 *   message.toLowerCase()
 * )
 *
 * normalizeErrorCase(ok("alice")) // ok("alice")
 * normalizeErrorCase(error("NOT FOUND")) // error("not found")
 * ```
 */
function errorThen(f) {
    return function (result) {
        if (isOk(result)) {
            return result;
        }
        return error(f(result.error));
    };
}
/**
 * Performs an operation that could succeed or fail on a successful result
 * Passes through a failed result.
 *
 * Takes a mapping function, then a result.
 * If the result is an Ok, applies the function to the data.
 * If the result is an Error, passes the Result through unchanged.
 *
 * The return value must itself be a result, which will be returned.
 * @returns - The Result from function f or the Error
 *
 * @param f - the function to run on the ok data
 * @param result - The result to match against
 *
 * ```javascript
 * function positiveAdder(n) {
 *   return n < 0 ? error("only positive") : ok(n + 1);
 * }
 *
 * okThen(positiveAdder)(ok(1)) // ok(2)
 * okThen(positiveAdder)(error("bad")) // error("bad")
 * okThen(positiveAdder)(ok(-1)) // error("only positive")
 * ```
 */
function okChain(f) {
    return function (result) {
        if (isError(result)) {
            return result;
        }
        return f(result.ok);
    };
}
/**
 * Attempts to rescue failed results. Passes successful ones through.
 *
 * Takes a mapping function, then a result.
 * If the result is an Error, applies the function to the data.
 * If the result is an Ok, passes the Result through unchanged.
 *
 * The return value must itself be a result, which will be returned.
 *
 * @param f - the function to run on the error data
 * @param result - The result to match against
 * @returns - The Result from function f or the Ok result
 *
 * ```javascript
 * const rescueNotFound = errorThen(errorMessage =>
 *   errorMessage === "not found" ? ok("unknown") : error(errorMessage)
 * );
 *
 * rescueNotFound(ok("alice")) // ok("alice")
 * rescueNotFound(error("not found")) // ok("unknown")
 * rescueNotFound(error("network error")) // error("network error")
 * ```
 */
function errorRescue(f) {
    return function (result) {
        if (isOk(result)) {
            return result;
        }
        return f(result.error);
    };
}
/**
 * Runs a function for side effects on the payload, only if the result is Ok.
 *
 * @param f - the function to run on the ok data
 * @param result - The result to match against
 * @returns The original result
 *
 * ```javascript
 * const result = fetchData();
 * // Log the data if the fetch succeeded.
 * okDo(console.log);
 * ```
 */
function okDo(f) {
    return function (result) {
        if (isOk(result)) {
            f(result.ok);
        }
        return result;
    };
}
/**
 * Runs a function for side effects on the payload, only if the result is Error.
 *
 * @param f - the function to run on the error message
 * @param result - The result to match against
 * @returns The original result
 *
 * ```javascript
 * const result = fetchData();
 * // Log an error if the fetch failed.
 * errorDo(console.error)(result);
 * ```
 */
function errorDo(f) {
    return function (result) {
        if (isError(result)) {
            f(result.error);
        }
        return result;
    };
}
/**
 * Replaces a value that's wrapped in an {ok: data}
 * Useful if you don't care about the data, just the fact that previous call succeeded.
 *
 * Takes a Result and a mapping function.
 * If the result is an Error, applies the function to the message.
 * If the result is an Ok, passes the Result through unchanged.
 *
 * It wraps the return value in an {error: new_message}.
 * @param f - the function to run on the ok data
 * @param result - The result to match against
 *
 * ```javascript
 * okReplace("fine")(ok(null)) // ok("fine")
 * ```
 */
function okReplace(newData) {
    return function (result) {
        if (isError(result)) {
            return result;
        }
        return ok(newData);
    };
}
/**
 * Replaces a message that's wrapped in an `error(message)`
 * Useful if you don't care about the old message, just the fact that previous call failed.
 *
 * Takes a Result and a mapping function.
 * If the result is an Error, applies the function to the message.
 * If the result is an Ok, passes the Result through unchanged.
 *
 * @param f - the function to run on the ok data
 * @param result - The result to match against
 *
 * ```javascript
 * errorReplace("something went wrong")(error(null)) // error("something went wrong")
 * ```
 */
function errorReplace(newError) {
    return function (result) {
        if (isOk(result)) {
            return result;
        }
        return error(newError);
    };
}
/**
 * Get the error message from a result. If it's an Ok, throw an error.
 * @returns the ok data
 *
 * ```typescript
 * const okResult = ok("good");
 * okOrThrow(result);
 * // "good"
 * ```
 *
 * ```typescript
 * const errorResult = error("bad");
 * okOrThrow(result);
 * // throws new Error("bad")
 * ```
 */
function okOrThrow(result) {
    if (isError(result))
        throw new Error(result.error);
    return result.ok;
}
/**
 * Get the error message from a result. If it's an Ok instead, throw an error.
 * @returns the error message
 *
 * ```typescript
 * errorOrThrow(error("bad"));
 * // "bad"
 *
 * errorOrThrow(ok("good"));
 * // throws new Error("good")
 * ```
 */
function errorOrThrow(result) {
    if (isOk(result))
        throw new Error(result.ok);
    return result.error;
}
/**
 * Takes a result, and runs either an onOk or onError function on it.
 * @param onOk - Function to run if the result is an Ok
 * @param onError - Function to run if the result is an Error
 * @param result - Result to match against
 * @returns The return value of the function that gets run.
 *
 * ```javascript
 * // Use `either` to unwrap a Result.
 * const userId = either(
 *   await fetchAUser(),
 *   user => user.id,
 *   () => null
 * )
 *
 * // Use `either` to act on both cases, but leave wrapped.
 * const userId = either(
 *   await fetchAUser(),
 *   user => ok(user.id),
 *   () => error("not found")
 * )
 * ```
 */
function either(result, onOk, onError) {
    if (isOk(result)) {
        return onOk(result.ok);
    }
    if (isError(result)) {
        return onError(result.error);
    }
    throw new Error("invalid result");
}
/**
 * Converts a result to a boolean.
 * @param result
 * @returns true if Ok, false if Error
 *
 * ```javascript
 * resultToBoolean(ok(1)) // true
 * resultToBoolean(error(1)) // false
 * ```
 */
function resultToBoolean(result) {
    return isOk(result) ? true : false;
}

/**
 * For checking that a collection of computations all succeeded.
 * Similar to Promise.all for Results.
 *
 * Takes a list of Results. If all are Ok, collects the data
 * in a list and returns ok([data]).
 * If any are Errors, returns the first error(msg)
 * @param results
 *
 * ```javascript
 * allOk([ok(1), ok(2), ok(3)]) // ok([1, 2, 3])
 *
 * allOk([ok(1), error(2), error(3)]) // error(2)
 * ```
 */
function allOk(results) {
    return results.reduce((acc, result) => {
        if (!isOk(acc))
            return acc;
        if (!isOk(result))
            return result;
        return ok([...acc.ok, result.ok]);
    }, ok([]));
}
/**
 * For checking that a collection async computations all succeeded.
 * Promise.all for Results wrapped in promises.
 *
 * Takes a list of Promise<Result>s. If all are Ok, collects the data
 * in a list and returns ok([data]).
 * If any are any promise OR result errors, returns the first error(msg)
 *
 * ```javascript
 * function countComments(postId) {
 *   return pipeA
 *     (fetchAllComments(postId)),
 *     (allOkAsync),
 *     (okThen(comments => comments.length))
 *     (errorReplace("some comments didn't load"))
 * }
 * ```
 */
function allOkAsync(promises) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = yield promiseToResult(Promise.all(promises));
        return okChain((results) => allOk(results))(results);
    });
}
/**
 * Find and return the first ok(data) in the collection. If there are no Ok values, return error(null)
 *
 * ```javascript
 * allOk([error(1), error(2), ok(3), ok(4)]) // ok(3)
 * allOk([error(1), error(2)]) // error(null)
 * ```
 */
function firstOk(results) {
    return results.find(isOk) || error(null);
}

/**
 * @module
 * Utilities to safely handle unsafe native JavaScript actions.
 */
/**
 * Call an action that could throw an error, and return a Result.
 * Successful actions will be wrapped in an ok
 * For predictable errors, you should provide a static or dynamic error handler
 * @param action - The unsafe action to perform
 * @param opts.errorMessage - A static value to return in case of an error
 * @param opts.errorHandler - A function that takes an error and turns it into something you can act on.
 */
function attempt(action, opts = {}) {
    try {
        return ok(action());
    }
    catch (e) {
        if (opts.errorHandler)
            return error(opts.errorHandler(e));
        if (opts.errorMessage)
            return error(opts.errorMessage);
        return error(e);
    }
}
/**
 * Safely parse JSON
 * @param json - Stringified JSON to parse
 * @param errorMessage - Optional message to return. Otherwise will return the parser's error message.
 */
function parseJson(json, opts = {}) {
    try {
        return ok(JSON.parse(json));
    }
    catch (e) {
        return error(opts.errorMessage || e.message);
    }
}

exports.ResultP = ResultP;
exports.allOk = allOk;
exports.allOkAsync = allOkAsync;
exports.attempt = attempt;
exports.either = either;
exports.error = error;
exports.errorDo = errorDo;
exports.errorDoAsync = errorDoAsync;
exports.errorOrThrow = errorOrThrow;
exports.errorReplace = errorReplace;
exports.errorRescue = errorRescue;
exports.errorRescueAsync = errorRescueAsync;
exports.errorThen = errorThen;
exports.firstOk = firstOk;
exports.isError = isError;
exports.isOk = isOk;
exports.isResult = isResult;
exports.ok = ok;
exports.okChain = okChain;
exports.okChainAsync = okChainAsync;
exports.okDo = okDo;
exports.okDoAsync = okDoAsync;
exports.okOrThrow = okOrThrow;
exports.okReplace = okReplace;
exports.okThen = okThen;
exports.parseJson = parseJson;
exports.promiseToResult = promiseToResult;
exports.resultToBoolean = resultToBoolean;
exports.resultify = resultify;
//# sourceMappingURL=result-async.cjs.js.map
