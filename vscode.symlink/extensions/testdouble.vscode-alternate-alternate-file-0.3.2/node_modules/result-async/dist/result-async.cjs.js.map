{"version":3,"file":"result-async.cjs.js","sources":["../src/result.ts","../src/async.ts","../src/sync.ts","../src/collection.ts","../src/utils.ts"],"sourcesContent":["/**\n * Represents the result of an operation that could succeed or fail.\n */\nexport type Result<OkData, ErrorMessage> =\n  | OkResult<OkData>\n  | ErrorResult<ErrorMessage>;\n\n/**\n * Wraps data in an Ok.\n * @param data The success payload\n *\n * ```javascript\n * ok(1)\n * ```\n */\nexport const ok = <T>(data: T): OkResult<T> => new OkResult(data);\n\n/**\n * Wraps a message in an Error.\n * @param data The success payload\n *\n * ```javascript\n * error(\"not found\")\n * ```\n */\nexport const error = <T>(message: T): ErrorResult<T> =>\n  new ErrorResult(message);\n\n/**\n * Type guard to check if a Result is Ok\n * @param result - The result to check\n *\n * ```javascript\n * const result = ok(1);\n *\n * if (isOk(result)) {\n *   result.ok // exists\n * }\n * ```\n */\nexport function isOk(result: Result<any, any>): result is OkResult<any> {\n  return \"ok\" in result;\n}\n\n/**\n * Type guard to check if a Result is an Error\n * @param result - The result to check\n *\n * ```javascript\n * const result = error(\"not found\");\n *\n * if (isError(result)) {\n *   result.error // exists\n * }\n * ```\n */\nexport function isError(result: Result<any, any>): result is ErrorResult<any> {\n  return \"error\" in result;\n}\n\n/**\n * Type guard to check if an object is a Result.\n * @param result - The object to check\n *\n * ```javascript\n * const result = ;\n *\n * isResult(error(\"not found\")) // true\n * ```\n */\nexport const isResult = (\n  result: Result<any, any> | any\n): result is Result<any, any> => isOk(result) || isError(result);\n\n/* tslint:disable:function-name */\n\n/**\n * Represents the result of a successful operation.\n * Create one with Result.ok(data)\n * Fantasy-land Functor\n */\nclass OkResult<T> {\n  constructor(public ok: T) {}\n\n  toString() {\n    return `{ok: ${this.ok}}`;\n  }\n\n  map<U>(f: (ok: T) => U): OkResult<U> {\n    return ok(f(this.ok));\n  }\n\n  \"fantasy-land/map\"<U>(f: (ok: T) => U): OkResult<U> {\n    return this.map(f);\n  }\n}\n\n/**\n * Represents the result of an unsuccessful operation.\n * Create one with Result.ok(data)\n * Fantasy-land Functor\n */\nclass ErrorResult<T> {\n  constructor(public error: T) {}\n\n  toString() {\n    return `{error: ${this.error}}`;\n  }\n\n  map(_f: (ok: any) => any): ErrorResult<T> {\n    return this;\n  }\n\n  \"fantasy-land/map\"(f: (ok: any) => any): ErrorResult<T> {\n    return this.map(f);\n  }\n}\n","import { Result, ok, error, isOk, isError } from \"./result\";\n\n/**\n * A Result, wrapped in a promise. The promise should never be rejected,\n * and should always resolve to an Ok or Error.\n */\nexport type ResultP<OkData, ErrorMessage> = Promise<\n  Result<OkData, ErrorMessage>\n>;\n// Solves an error with returning ResultP from an async function.\n// tslint:disable-next-line:variable-name\nexport const ResultP = Promise;\n\n/**\n * Chains together async operations that may succeed or fail\n *\n * Takes a Result and a mapping function.\n * If the result is an Ok, applies the function to the data.\n * If the result is an Error, passes the Result through unchanged.\n *\n * @param f - the function to run on the ok data\n * @param result - The result to match against\n * @returns - The Result from function f or the Error\n *\n * ```javascript\n * pipeA\n *   (fetchUser())\n *   (okChainAsync(user => fetchComments(user.id)))\n *   (okDo(comments => console.log('total comments:', comments.length))\n *   .value\n * ```\n */\nexport function okChainAsync<OkData, OkOutput, ErrorOutput>(\n  f: (ok: OkData) => ResultP<OkOutput, ErrorOutput>\n) {\n  return async function<ErrorMessage>(\n    result: Result<OkData, ErrorMessage>\n  ): ResultP<OkOutput, ErrorMessage | ErrorOutput> {\n    if (isError(result)) {\n      return result;\n    }\n\n    return f(result.ok);\n  };\n}\n\n/**\n * Chains together async operations that may succeed or fail\n *\n * Takes a Result and a mapping function.\n * If the result is an Error, applies the function to the data and returns the new promise-wrapped result.\n * If the result is an Ok, passes the Result through unchanged.\n *\n * @param f - the function to run on the error message\n * @param result - The result to match against\n * @returns - The Result from function f or the Ok result\n *\n * ```javascript\n * const fetchData = () => fetch(\"https://example.com/data\");\n * pipeA\n *   (getCachedData)\n *   (errorRescueAsync(fetchData))\n *   (okThen(transformData))\n *   .value\n * ```\n */\nexport function errorRescueAsync<ErrorMessage, OkOutput, ErrorOutput>(\n  f: (ok: ErrorMessage) => ResultP<OkOutput, ErrorOutput>\n) {\n  return async function<OkData>(\n    result: Result<OkData, ErrorMessage>\n  ): ResultP<OkData | OkOutput, ErrorOutput> {\n    if (isOk(result)) {\n      return result;\n    }\n\n    return f(result.error);\n  };\n}\n\n/**\n * Runs a function for side effects on the payload, only if the result is Ok.\n *\n * @param f - the async function to run on the ok data\n * @param result - The result to match against\n * @returns A promise of the the original result\n *\n * ```javascript\n * pipeA(\n *   (fetchData)\n *   // Saves to cache, and awaits completion before moving on.\n *   (okDoAsync(saveToCache))\n *   (okThen(transformData))\n * ```\n */\nexport function okDoAsync<OkData>(f: (ok: OkData) => any) {\n  return async function<ErrorMessage>(\n    result: Result<OkData, ErrorMessage>\n  ): ResultP<OkData, ErrorMessage> {\n    if (isOk(result)) {\n      await f(result.ok);\n    }\n    return result;\n  };\n}\n\n/**\n * Runs a function for side effects on the payload, only if the result is Error. Waits for the side effect to complete before returning.\n *\n * @param f - the function to run on the error message\n * @param result - The result to match against\n * @returns a promise of the original Result\n *\n * ```javascript\n * pipeA(\n *   (fetchData)\n *   // Logs an error, and awaits completion before moving on.\n *   (errorDoAsync(logError))\n *   (okThen(transformData))\n * ```\n */\nexport function errorDoAsync<ErrorMessage>(f: (ok: ErrorMessage) => any) {\n  return async function<OkData>(\n    result: Result<OkData, ErrorMessage>\n  ): ResultP<OkData, ErrorMessage> {\n    if (isError(result)) {\n      await f(result.error);\n    }\n    return result;\n  };\n}\n\n/**\n * Awaits a promise, and returns a result based on the outcome\n *\n * Note that the Error case isn't typesafe, since promises don't have an\n * error type, just a success one. It's probably a good idea to use a\n * `errorThen` or `errorReplace` to handle errors and soon as possible.\n *\n * @param promise\n * @returns Ok if the promise resolved, Error if it was rejected.\n *\n * ```javascript\n * pipeA(\n *   (promiseToResult(fetch(\"http://example.com/data\")))\n *   (errorThen(handleError))\n *   (okThen(transformData))\n * ```\n */\nexport function promiseToResult<OkData>(\n  promise: Promise<OkData>\n): ResultP<OkData, any> {\n  return promise.then(ok).catch(error);\n}\n\n/**\n * Converts a function that returns a promise to one that always resolved to a Result\n *\n * Note that the Error case isn't typesafe, since promises don't have an\n * error type, just a success one. It's probably a good idea to use a\n * `errorThen` or `errorReplace` to handle errors and soon as possible.\n *\n * @param f A function that returns a promise\n * @returns a function that returns a promise that always resolves to a Result\n *\n * ```javascript\n * const writeFile = resultify(promisify(fs.writeFile));\n *\n * pipeA(\n *   (writeFile(\"path/to/file\"))\n *   (errorThen(handleError))\n *   (okThen(transformFileData))\n * )\n * ```\n */\nexport function resultify<Args extends any[], OkData>(\n  f: (...args: Args) => Promise<OkData>\n) {\n  return function(...args: Args): ResultP<OkData, any> {\n    return promiseToResult(f(...args));\n  };\n}\n","import { Result, ok, error, isOk, isError } from \"./result\";\n\n/**\n * Transforms a successful result, and passes through a failed result.\n *\n * Takes a mapping function, then a result.\n * If the result is an Ok, applies the function to the data.\n * If the result is an Error, passes the Result through unchanged.\n *\n * Wraps the output of the function in an Ok.\n *\n * @param f - the function to run on the ok data\n * @param result - The result to match against\n *\n * ```javascript\n * function add1(n) {\n *   return n + 1\n * }\n *\n * okThen(add1)(ok(1)) // ok(2)\n * okThen(add1)(error(\"bad\")) // error(\"bad\")\n * okThen(add1)(ok(-1)) // ok(0)\n * ```\n */\n\nexport function okThen<OkData, OkOutput>(f: (ok: OkData) => OkOutput) {\n  return function<ErrorMessage>(\n    result: Result<OkData, ErrorMessage>\n  ): Result<OkOutput, ErrorMessage> {\n    if (isError(result)) {\n      return result;\n    }\n\n    return ok(f(result.ok));\n  };\n}\n\n/**\n * Transforms a failed result, and passes through a successful result.\n *\n * Takes a mapping function, then a result.\n * If the result is an Error, applies the function to the data.\n * If the result is an Ok, passes the Result through unchanged.\n *\n * Wraps the output of the function in an Error.\n *\n * @param f - the function to run on the error data\n * @param result - The result to match against\n * @returns - The Result from function f or the Ok result\n *\n * ```javascript\n * const normalizeErrorCase = errorThen(message =>\n *   message.toLowerCase()\n * )\n *\n * normalizeErrorCase(ok(\"alice\")) // ok(\"alice\")\n * normalizeErrorCase(error(\"NOT FOUND\")) // error(\"not found\")\n * ```\n */\nexport function errorThen<ErrorMessage, ErrorOutput>(\n  f: (error: ErrorMessage) => ErrorOutput\n) {\n  return function<OkData>(\n    result: Result<OkData, ErrorMessage>\n  ): Result<OkData, ErrorOutput> {\n    if (isOk(result)) {\n      return result;\n    }\n\n    return error(f(result.error));\n  };\n}\n\n/**\n * Performs an operation that could succeed or fail on a successful result\n * Passes through a failed result.\n *\n * Takes a mapping function, then a result.\n * If the result is an Ok, applies the function to the data.\n * If the result is an Error, passes the Result through unchanged.\n *\n * The return value must itself be a result, which will be returned.\n * @returns - The Result from function f or the Error\n *\n * @param f - the function to run on the ok data\n * @param result - The result to match against\n *\n * ```javascript\n * function positiveAdder(n) {\n *   return n < 0 ? error(\"only positive\") : ok(n + 1);\n * }\n *\n * okThen(positiveAdder)(ok(1)) // ok(2)\n * okThen(positiveAdder)(error(\"bad\")) // error(\"bad\")\n * okThen(positiveAdder)(ok(-1)) // error(\"only positive\")\n * ```\n */\nexport function okChain<OkData, OkOutput, ErrorOutput>(\n  f: (ok: OkData) => Result<OkOutput, ErrorOutput>\n) {\n  return function<ErrorMessage>(\n    result: Result<OkData, ErrorMessage>\n  ): Result<OkOutput, ErrorMessage | ErrorOutput> {\n    if (isError(result)) {\n      return result;\n    }\n\n    return f(result.ok);\n  };\n}\n\n/**\n * Attempts to rescue failed results. Passes successful ones through.\n *\n * Takes a mapping function, then a result.\n * If the result is an Error, applies the function to the data.\n * If the result is an Ok, passes the Result through unchanged.\n *\n * The return value must itself be a result, which will be returned.\n *\n * @param f - the function to run on the error data\n * @param result - The result to match against\n * @returns - The Result from function f or the Ok result\n *\n * ```javascript\n * const rescueNotFound = errorThen(errorMessage =>\n *   errorMessage === \"not found\" ? ok(\"unknown\") : error(errorMessage)\n * );\n *\n * rescueNotFound(ok(\"alice\")) // ok(\"alice\")\n * rescueNotFound(error(\"not found\")) // ok(\"unknown\")\n * rescueNotFound(error(\"network error\")) // error(\"network error\")\n * ```\n */\nexport function errorRescue<ErrorMessage, OkOutput, ErrorOutput>(\n  f: (ok: ErrorMessage) => Result<OkOutput, ErrorOutput>\n) {\n  return function<OkData>(\n    result: Result<OkData, ErrorMessage>\n  ): Result<OkData | OkOutput, ErrorOutput> {\n    if (isOk(result)) {\n      return result;\n    }\n\n    return f(result.error);\n  };\n}\n\n/**\n * Runs a function for side effects on the payload, only if the result is Ok.\n *\n * @param f - the function to run on the ok data\n * @param result - The result to match against\n * @returns The original result\n *\n * ```javascript\n * const result = fetchData();\n * // Log the data if the fetch succeeded.\n * okDo(console.log);\n * ```\n */\nexport function okDo<OkData, ErrorMessage>(f: (ok: OkData) => any) {\n  return function(\n    result: Result<OkData, ErrorMessage>\n  ): Result<OkData, ErrorMessage> {\n    if (isOk(result)) {\n      f(result.ok);\n    }\n    return result;\n  };\n}\n\n/**\n * Runs a function for side effects on the payload, only if the result is Error.\n *\n * @param f - the function to run on the error message\n * @param result - The result to match against\n * @returns The original result\n *\n * ```javascript\n * const result = fetchData();\n * // Log an error if the fetch failed.\n * errorDo(console.error)(result);\n * ```\n */\nexport function errorDo<OkData, ErrorMessage>(f: (ok: ErrorMessage) => any) {\n  return function(\n    result: Result<OkData, ErrorMessage>\n  ): Result<OkData, ErrorMessage> {\n    if (isError(result)) {\n      f(result.error);\n    }\n    return result;\n  };\n}\n\n/**\n * Replaces a value that's wrapped in an {ok: data}\n * Useful if you don't care about the data, just the fact that previous call succeeded.\n *\n * Takes a Result and a mapping function.\n * If the result is an Error, applies the function to the message.\n * If the result is an Ok, passes the Result through unchanged.\n *\n * It wraps the return value in an {error: new_message}.\n * @param f - the function to run on the ok data\n * @param result - The result to match against\n *\n * ```javascript\n * okReplace(\"fine\")(ok(null)) // ok(\"fine\")\n * ```\n */\nexport function okReplace<OkOutput>(newData: OkOutput) {\n  return function<ErrorMessage>(\n    result: Result<any, ErrorMessage>\n  ): Result<OkOutput, ErrorMessage> {\n    if (isError(result)) {\n      return result;\n    }\n\n    return ok(newData);\n  };\n}\n\n/**\n * Replaces a message that's wrapped in an `error(message)`\n * Useful if you don't care about the old message, just the fact that previous call failed.\n *\n * Takes a Result and a mapping function.\n * If the result is an Error, applies the function to the message.\n * If the result is an Ok, passes the Result through unchanged.\n *\n * @param f - the function to run on the ok data\n * @param result - The result to match against\n *\n * ```javascript\n * errorReplace(\"something went wrong\")(error(null)) // error(\"something went wrong\")\n * ```\n */\nexport function errorReplace<ErrorOutput>(newError: ErrorOutput) {\n  return function<OkData>(\n    result: Result<OkData, any>\n  ): Result<OkData, ErrorOutput> {\n    if (isOk(result)) {\n      return result;\n    }\n\n    return error(newError);\n  };\n}\n\n/**\n * Get the error message from a result. If it's an Ok, throw an error.\n * @returns the ok data\n *\n * ```typescript\n * const okResult = ok(\"good\");\n * okOrThrow(result);\n * // \"good\"\n * ```\n *\n * ```typescript\n * const errorResult = error(\"bad\");\n * okOrThrow(result);\n * // throws new Error(\"bad\")\n * ```\n */\nexport function okOrThrow<OkData>(result: Result<OkData, any>): OkData {\n  if (isError(result)) throw new Error(result.error);\n\n  return result.ok;\n}\n\n/**\n * Get the error message from a result. If it's an Ok instead, throw an error.\n * @returns the error message\n *\n * ```typescript\n * errorOrThrow(error(\"bad\"));\n * // \"bad\"\n *\n * errorOrThrow(ok(\"good\"));\n * // throws new Error(\"good\")\n * ```\n */\nexport function errorOrThrow<ErrorMessage>(\n  result: Result<any, ErrorMessage>\n): ErrorMessage {\n  if (isOk(result)) throw new Error(result.ok);\n\n  return result.error;\n}\n\n/**\n * Takes a result, and runs either an onOk or onError function on it.\n * @param onOk - Function to run if the result is an Ok\n * @param onError - Function to run if the result is an Error\n * @param result - Result to match against\n * @returns The return value of the function that gets run.\n *\n * ```javascript\n * // Use `either` to unwrap a Result.\n * const userId = either(\n *   await fetchAUser(),\n *   user => user.id,\n *   () => null\n * )\n *\n * // Use `either` to act on both cases, but leave wrapped.\n * const userId = either(\n *   await fetchAUser(),\n *   user => ok(user.id),\n *   () => error(\"not found\")\n * )\n * ```\n */\nexport function either<OkData, ErrorMessage, OkOutput, ErrorOutput>(\n  result: Result<OkData, ErrorMessage>,\n  onOk: (ok: OkData) => OkOutput,\n  onError: (error: ErrorMessage) => ErrorOutput\n): OkOutput | ErrorOutput {\n  if (isOk(result)) {\n    return onOk(result.ok);\n  }\n  if (isError(result)) {\n    return onError(result.error);\n  }\n  throw new Error(\"invalid result\");\n}\n\n/**\n * Converts a result to a boolean.\n * @param result\n * @returns true if Ok, false if Error\n *\n * ```javascript\n * resultToBoolean(ok(1)) // true\n * resultToBoolean(error(1)) // false\n * ```\n */\nexport function resultToBoolean(result: Result<any, any>): boolean {\n  return isOk(result) ? true : false;\n}\n","import { Result, isOk, ok, error } from \"./result\";\nimport { okChain } from \"./sync\";\nimport { ResultP, promiseToResult } from \"./async\";\n\n/**\n * For checking that a collection of computations all succeeded.\n * Similar to Promise.all for Results.\n *\n * Takes a list of Results. If all are Ok, collects the data\n * in a list and returns ok([data]).\n * If any are Errors, returns the first error(msg)\n * @param results\n *\n * ```javascript\n * allOk([ok(1), ok(2), ok(3)]) // ok([1, 2, 3])\n *\n * allOk([ok(1), error(2), error(3)]) // error(2)\n * ```\n */\nexport function allOk<OkData, ErrorMessage>(\n  results: Result<OkData, ErrorMessage>[]\n): Result<OkData[], ErrorMessage> {\n  return results.reduce((acc: Result<OkData[], ErrorMessage>, result): Result<\n    OkData[],\n    ErrorMessage\n  > => {\n    if (!isOk(acc)) return acc;\n\n    if (!isOk(result)) return result;\n\n    return ok([...acc.ok, result.ok]);\n  }, ok([]));\n}\n\n/**\n * For checking that a collection async computations all succeeded.\n * Promise.all for Results wrapped in promises.\n *\n * Takes a list of Promise<Result>s. If all are Ok, collects the data\n * in a list and returns ok([data]).\n * If any are any promise OR result errors, returns the first error(msg)\n *\n * ```javascript\n * function countComments(postId) {\n *   return pipeA\n *     (fetchAllComments(postId)),\n *     (allOkAsync),\n *     (okThen(comments => comments.length))\n *     (errorReplace(\"some comments didn't load\"))\n * }\n * ```\n */\nexport async function allOkAsync<OkData, ErrorMessage>(\n  promises: ResultP<OkData, ErrorMessage>[]\n): ResultP<OkData[], ErrorMessage> {\n  const results = await promiseToResult(Promise.all(promises));\n\n  return okChain((results: Result<OkData, ErrorMessage>[]) => allOk(results))(\n    results\n  );\n}\n\n/**\n * Find and return the first ok(data) in the collection. If there are no Ok values, return error(null)\n *\n * ```javascript\n * allOk([error(1), error(2), ok(3), ok(4)]) // ok(3)\n * allOk([error(1), error(2)]) // error(null)\n * ```\n */\nexport function firstOk<OkData>(\n  results: Result<OkData, any>[]\n): Result<OkData, null> {\n  return results.find(isOk) || error(null);\n}\n","/**\n * @module\n * Utilities to safely handle unsafe native JavaScript actions.\n */\n\nimport { ok, error, Result } from \"./result\";\n\n/**\n * Call an action that could throw an error, and return a Result.\n * Successful actions will be wrapped in an ok\n * For predictable errors, you should provide a static or dynamic error handler\n * @param action - The unsafe action to perform\n * @param opts.errorMessage - A static value to return in case of an error\n * @param opts.errorHandler - A function that takes an error and turns it into something you can act on.\n */\nexport function attempt<OkData, ErrorMessage>(\n  action: () => OkData,\n  opts: {\n    errorMessage?: ErrorMessage;\n    errorHandler?: (error: any) => ErrorMessage;\n  } = {}\n): Result<OkData, ErrorMessage> {\n  try {\n    return ok(action());\n  } catch (e) {\n    if (opts.errorHandler) return error(opts.errorHandler(e));\n    if (opts.errorMessage) return error(opts.errorMessage);\n    return error(e);\n  }\n}\n\n/**\n * Safely parse JSON\n * @param json - Stringified JSON to parse\n * @param errorMessage - Optional message to return. Otherwise will return the parser's error message.\n */\nexport function parseJson<T, ErrorMessage = string>(\n  json: string,\n  opts: { errorMessage?: ErrorMessage } = {}\n): Result<T, ErrorMessage> {\n  try {\n    return ok(JSON.parse(json));\n  } catch (e) {\n    return error(opts.errorMessage || e.message);\n  }\n}\n"],"names":[],"mappings":"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"}