import { Result } from "./result";
/**
 * A Result, wrapped in a promise. The promise should never be rejected,
 * and should always resolve to an Ok or Error.
 */
export declare type ResultP<OkData, ErrorMessage> = Promise<Result<OkData, ErrorMessage>>;
export declare const ResultP: PromiseConstructor;
/**
 * Chains together async operations that may succeed or fail
 *
 * Takes a Result and a mapping function.
 * If the result is an Ok, applies the function to the data.
 * If the result is an Error, passes the Result through unchanged.
 *
 * @param f - the function to run on the ok data
 * @param result - The result to match against
 * @returns - The Result from function f or the Error
 *
 * ```javascript
 * pipeA
 *   (fetchUser())
 *   (okChainAsync(user => fetchComments(user.id)))
 *   (okDo(comments => console.log('total comments:', comments.length))
 *   .value
 * ```
 */
export declare function okChainAsync<OkData, OkOutput, ErrorOutput>(f: (ok: OkData) => ResultP<OkOutput, ErrorOutput>): <ErrorMessage>(result: Result<OkData, ErrorMessage>) => Promise<Result<OkOutput, ErrorOutput | ErrorMessage>>;
/**
 * Chains together async operations that may succeed or fail
 *
 * Takes a Result and a mapping function.
 * If the result is an Error, applies the function to the data and returns the new promise-wrapped result.
 * If the result is an Ok, passes the Result through unchanged.
 *
 * @param f - the function to run on the error message
 * @param result - The result to match against
 * @returns - The Result from function f or the Ok result
 *
 * ```javascript
 * const fetchData = () => fetch("https://example.com/data");
 * pipeA
 *   (getCachedData)
 *   (errorRescueAsync(fetchData))
 *   (okThen(transformData))
 *   .value
 * ```
 */
export declare function errorRescueAsync<ErrorMessage, OkOutput, ErrorOutput>(f: (ok: ErrorMessage) => ResultP<OkOutput, ErrorOutput>): <OkData>(result: Result<OkData, ErrorMessage>) => Promise<Result<OkOutput | OkData, ErrorOutput>>;
/**
 * Runs a function for side effects on the payload, only if the result is Ok.
 *
 * @param f - the async function to run on the ok data
 * @param result - The result to match against
 * @returns A promise of the the original result
 *
 * ```javascript
 * pipeA(
 *   (fetchData)
 *   // Saves to cache, and awaits completion before moving on.
 *   (okDoAsync(saveToCache))
 *   (okThen(transformData))
 * ```
 */
export declare function okDoAsync<OkData>(f: (ok: OkData) => any): <ErrorMessage>(result: Result<OkData, ErrorMessage>) => Promise<Result<OkData, ErrorMessage>>;
/**
 * Runs a function for side effects on the payload, only if the result is Error. Waits for the side effect to complete before returning.
 *
 * @param f - the function to run on the error message
 * @param result - The result to match against
 * @returns a promise of the original Result
 *
 * ```javascript
 * pipeA(
 *   (fetchData)
 *   // Logs an error, and awaits completion before moving on.
 *   (errorDoAsync(logError))
 *   (okThen(transformData))
 * ```
 */
export declare function errorDoAsync<ErrorMessage>(f: (ok: ErrorMessage) => any): <OkData>(result: Result<OkData, ErrorMessage>) => Promise<Result<OkData, ErrorMessage>>;
/**
 * Awaits a promise, and returns a result based on the outcome
 *
 * Note that the Error case isn't typesafe, since promises don't have an
 * error type, just a success one. It's probably a good idea to use a
 * `errorThen` or `errorReplace` to handle errors and soon as possible.
 *
 * @param promise
 * @returns Ok if the promise resolved, Error if it was rejected.
 *
 * ```javascript
 * pipeA(
 *   (promiseToResult(fetch("http://example.com/data")))
 *   (errorThen(handleError))
 *   (okThen(transformData))
 * ```
 */
export declare function promiseToResult<OkData>(promise: Promise<OkData>): ResultP<OkData, any>;
/**
 * Converts a function that returns a promise to one that always resolved to a Result
 *
 * Note that the Error case isn't typesafe, since promises don't have an
 * error type, just a success one. It's probably a good idea to use a
 * `errorThen` or `errorReplace` to handle errors and soon as possible.
 *
 * @param f A function that returns a promise
 * @returns a function that returns a promise that always resolves to a Result
 *
 * ```javascript
 * const writeFile = resultify(promisify(fs.writeFile));
 *
 * pipeA(
 *   (writeFile("path/to/file"))
 *   (errorThen(handleError))
 *   (okThen(transformFileData))
 * )
 * ```
 */
export declare function resultify<Args extends any[], OkData>(f: (...args: Args) => Promise<OkData>): (...args: Args) => Promise<Result<OkData, any>>;
