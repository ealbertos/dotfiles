{"version":3,"file":"alternate-file.js","sources":["../src/utils.ts","../src/AlternatePattern.ts","../node_modules/pipeout/dist/pipeout.js","../src/File.ts","../src/Projections.ts","../src/AlternateFileNotFoundError.ts","../src/InitializeProjections.ts"],"sourcesContent":["/**\n * Pipeable console.log\n * @param args - Varadic args to tag the log with.\n * @param data - Final data to console.log\n */\nexport const log = (...args: any[]) => <T>(data: T): T => {\n  const logArgs = args.concat([data]);\n  console.log(...logArgs);\n  return data;\n};\n\n/**\n * Async sleep\n * @param milliseconds\n */\nexport const sleep = (milliseconds: number): Promise<number> => {\n  return new Promise(resolve => setTimeout(resolve, milliseconds));\n};\n\n/**\n * Zip two arrays together. Output is the length of the first array.\n * @param array1\n * @param array2\n */\nexport const zip = <T, U>(array1: T[], array2: U[]): [T, U][] =>\n  array1.map((a, i) => {\n    const b = array2[i];\n    return [a, b] as [T, U];\n  });\n\n/**\n * Pipeable version of String.replace\n * @param searchValue - The pattern to replace\n * @param replaceValue  - The value to replace the pattern with\n * @returns the updated string.\n */\nexport const replace = (searchValue: RegExp | string, replaceValue: string) => (\n  oldString: string\n): string => oldString.replace(searchValue, replaceValue);\n\nexport const map = <T, U>(f: (x: T) => U) => (xs: T[]): U[] => xs.map(f);\n\n/** Convert an object to a list of tuples. */\nexport function toPairs<Value>(dictionary: {\n  [key: string]: Value;\n}): [string, Value][] {\n  return Object.keys(dictionary).map(\n    key => [key, dictionary[key]] as [string, Value]\n  );\n}\n\n/** Shallow flatten a list. */\nexport function flatten<T>(xss: T[][]): T[] {\n  return xss.reduce((acc, xs) => acc.concat(xs), []);\n}\n\nexport function compact<T>(xs: (T | undefined | null)[]): T[] {\n  return reject(isNil, xs) as T[];\n}\n\nexport function filter<T>(f: (x: T) => boolean, xs: T[]): T[] {\n  return xs.reduce((acc: T[], x: T) => {\n    if (!f(x)) return acc;\n\n    acc.push(x);\n    return acc;\n  }, []);\n}\n\nexport function reject<T>(f: (x: T) => boolean, xs: T[]): T[] {\n  return filter(x => !f(x), xs);\n}\n\nexport function isNil(x: any): boolean {\n  return x === undefined || x === null;\n}\n\nexport const titleCase = (s: string): string =>\n  s ? s.charAt(0).toUpperCase() + s.slice(1) : \"\";\n","import * as path from \"path\";\nimport * as utils from \"./utils\";\nimport { isError, ok, error, Result } from \"result-async\";\n\n/**\n * A computer-friendly representation of paths for switching between alternate files.\n */\nexport interface t {\n  main: string;\n  alternate: string;\n}\n\nconst slash = \"[/\\\\]\";\nconst notSlash = \"[^/\\\\]\";\nconst escapedSlash = \"[/\\\\\\\\]\";\n\nconst anyBackslashRegex = /\\\\/g;\nconst escapedBackslash = \"\\\\\\\\\";\n\nconst transformationPattern = \"{([^{}]+)}\";\n\nconst dirnameRegex = new RegExp(`{dirname}${escapedSlash}`, \"g\");\nconst basenameRegex = /{basename}/g;\n\nconst dirnamePattern = `(?:(.+)${slash})?`;\nconst basenamePattern = `(${notSlash}+)`;\n\n/**\n * Given a filePath and an AlternatePath, calculate if the filePath matches\n * a pattern, and if it does, calculate what the matching alternate file path\n * would be.\n * @param path - the absolute path to the file\n * @param projectionsPath - the absolute path to the projections file\n * @param alternatePath - the AlternatePath object to match against.\n */\nexport const alternatePath = (path: string, projectionsPath: string) => ({\n  main,\n  alternate\n}: t): string | null =>\n  alternatePathForSide(alternate, main, path, projectionsPath) ||\n  alternatePathForSide(main, alternate, path, projectionsPath);\n\nconst alternatePathForSide = (\n  pathPattern: string,\n  alternatePattern: string,\n  filePath: string,\n  projectionsPath: string\n): string | null => {\n  const absolutePattern = combinePaths(projectionsPath, pathPattern);\n  const absoluteAlternatePattern = combinePaths(\n    projectionsPath,\n    alternatePattern\n  );\n\n  const matchResult = matchPatternToPath(absolutePattern, filePath);\n  if (isError(matchResult)) return null;\n\n  const pathMatches = matchResult.ok;\n  const transformations = patternToTransformations(absolutePattern);\n\n  return fillPattern(transformations, pathMatches, absoluteAlternatePattern);\n};\n\n/**\n * Take the available transformation names and match values, and use them to fill up the alternate pattern.\n * @param transformations\n * @param matches\n * @param alternatePattern\n * @returns A complete file path.\n */\nconst fillPattern = (\n  transformations: string[],\n  matches: string[],\n  alternatePattern: string\n): string => {\n  const filledPath = utils\n    .zip(transformations, matches)\n    .reduce(\n      (alternatePattern: string, [transformation, match]: [string, string]) =>\n        alternatePattern.replace(`{${transformation}}`, match || \"\"),\n      alternatePattern\n    );\n\n  return path.normalize(filledPath);\n};\n\n/**\n * Extract a list of transformations from a pattern, to be zipped with their matches.\n * @param pathPattern\n * @returns list of transformation names\n */\nconst patternToTransformations = (pathPattern: string) => {\n  const regex = new RegExp(transformationPattern, \"g\");\n\n  const transformations: string[] = [];\n  let matches: RegExpExecArray | null;\n\n  while ((matches = regex.exec(pathPattern)) !== null) {\n    transformations.push(matches[1]);\n  }\n\n  return transformations;\n};\n\n/**\n * Take a path pattern string, and use it to try to pull out matches from the file path.\n * @param pathPattern - String to be converted to regex\n * @param filePath - Current file\n * @returns Ok(matches) | Error(null) if no matches\n */\nconst matchPatternToPath = (\n  pathPattern: string,\n  filePath: string\n): Result<string[], null> => {\n  const regex = patternToRegex(pathPattern);\n  const matches = filePath.match(regex);\n\n  if (!matches || !matches[2]) return error(null);\n\n  const pathMatches = matches.slice(1);\n\n  return ok(pathMatches);\n};\n\n/**\n * Take a projections pattern, and convert it to a regex that will extract the variable parts.\n */\nconst patternToRegex = (pathPattern: string): RegExp => {\n  const regexPattern = pathPattern\n    .replace(dirnameRegex, dirnamePattern)\n    .replace(basenameRegex, basenamePattern);\n\n  const escapedPattern = escapeBackslashes(regexPattern);\n\n  return new RegExp(escapedPattern);\n};\n\n/**\n * Append a pattern to the absolute path of the projections file\n * @param projectionsPath - absolute path to the projections file\n * @param filePattern -\n */\nconst combinePaths = (projectionsPath: string, filePattern: string): string => {\n  const projectionsDir = path.dirname(projectionsPath);\n  return path.resolve(projectionsDir, filePattern);\n};\n\n/**\n * Escape backslashes before converting a string to a regex.\n */\nconst escapeBackslashes = (pattern: string): string =>\n  pattern.replace(anyBackslashRegex, escapedBackslash);\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n/**\r\n * Pipe a value through a series of transformers.\r\n * @param value - The value to send through the pipeline.\r\n * @returns nextPipe - Pass a transformer to pipe again. Or, use .value to get the transformed value.\r\n */\r\nfunction pipe(value) {\r\n    function nextPipe(transformer) {\r\n        return pipe(transformer(value));\r\n    }\r\n    nextPipe.value = value;\r\n    return nextPipe;\r\n}\r\n/**\r\n * Pipe a value through a series of transformers,\r\n * where the value can be a promise and transformers can return promises.\r\n * @param value - The value to send through the pipeline.\r\n * @returns nextPipe - Pass a transformer to pipe again. Or, use .value to get the transformed value.\r\n */\r\nfunction pipeA(value) {\r\n    function nextPipe(transformer) {\r\n        return pipeA(Promise.resolve(value).then(transformer));\r\n    }\r\n    nextPipe.value = Promise.resolve(value);\r\n    return nextPipe;\r\n}\r\n/**\r\n * Create a series of transformers to pipe a value through.\r\n * @param transformer - A function that transforms the value.\r\n * @returns nextPipe - Pass a transformer to pipe again. Or, call .run to run the transforms.\r\n */\r\nfunction piper(transformer) {\r\n    function nextPipe(nextTransformer) {\r\n        return piper(function (value) {\r\n            return nextTransformer(transformer(value));\r\n        });\r\n    }\r\n    nextPipe.run = (value) => transformer(value);\r\n    return nextPipe;\r\n}\r\n/**\r\n * Create a series of transformers to pipe a value through,\r\n * where the value can be a promise and transformers can return promises.\r\n * @param transformer - A function that transforms the value.\r\n * @returns nextPipe - Pass a transformer to pipe again. Or, call .run to run the transforms.\r\n */\r\nfunction piperA(transformer) {\r\n    function nextPipe(nextTransformer) {\r\n        return piperA(function (valuePromise) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                const value = yield valuePromise;\r\n                const next = yield transformer(value);\r\n                return nextTransformer(next);\r\n            });\r\n        });\r\n    }\r\n    nextPipe.run = function (value) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return transformer(yield value);\r\n        });\r\n    };\r\n    return nextPipe;\r\n}\n\nexport { pipe as pip, pipe, pipeA, piper, piperA };\n//# sourceMappingURL=pipeout.js.map\n","import * as fs from \"fs\";\nimport * as path from \"path\";\nimport findUp from \"find-up\";\nimport { promisify } from \"util\";\nimport { map } from \"./utils\";\n\nimport {\n  error,\n  errorReplace,\n  errorThen,\n  firstOk,\n  ok,\n  okChainAsync,\n  okReplace,\n  Result,\n  resultify,\n  ResultP\n} from \"result-async\";\nimport { pipeA } from \"pipeout\";\n\nexport type t = string;\n\n/**\n * Find a file by recursively walking up the directory chain.\n * @param fileName - The filename to look for.\n * @param fromFilePath - The file to start looking from\n * @return the full path/\"not found\"\n */\nexport const findFileFrom = (fileName: string) => async (\n  fromFilePath: string\n): ResultP<string, string> => {\n  const filePath = await findUp(fileName, { cwd: fromFilePath });\n\n  return filePath ? ok(filePath) : error(\"file not found\");\n};\n\n/**\n * Create a new file, with contents. Also creates the path if necessary.\n * @param path\n * @param contents\n * @returns filePath\n */\nexport async function makeFile(filePath: string, contents: string = \"\") {\n  // prettier-ignore\n  return pipeA\n    (filePath)\n    (makeDirectoryForFile)\n    (okChainAsync(makeFileShallow(contents)))\n    .value\n}\n\n/**\n * Create a new file, with contents. Fails if the directory doesn't exist.\n * @param path\n * @param contents\n * @returns filePath\n */\nexport const makeFileShallow = (contents: string) => (\n  filePath: string\n): ResultP<string, string> => {\n  // prettier-ignore\n  return pipeA\n    (writeFile(filePath, contents, { flag: \"wx\" }))\n    (errorReplace(`${filePath} already exists`))\n    (okReplace(filePath))\n    .value\n};\n\nexport async function makeDirectoryDeep(\n  dirPath: string\n): ResultP<string, string> {\n  await mkdir(dirPath, { recursive: true });\n\n  return ok(dirPath);\n}\n\n/**\n * Delete a file by path\n * @param filePath\n * @returns ResultP<the deleted file, an error message>\n */\nexport const deleteFile = (filePath: string): ResultP<string, string> => {\n  // prettier-ignore\n  return pipeA\n    (filePath)\n    (unlink)\n    (okReplace(filePath))\n    (errorReplace(`can't delete ${filePath}`))\n    .value\n};\n\n/**\n * Check if any of the provided files exists.\n * @param filePaths\n * @returns Ok(filePath) | Error(null)\n */\nexport const findExisting = async (filePaths: t[]): ResultP<t, string[]> => {\n  // prettier-ignore\n  return pipeA\n    (filePaths)\n    (map(fileExists))\n    (files => Promise.all(files))\n    (file => firstOk(file))\n    (errorThen(always(filePaths)))\n    .value\n};\n\n/**\n * Read the contents of a file.\n */\nexport const readFile = (path: string): ResultP<string, any> =>\n  fsReadFile(path, \"utf8\") as ResultP<string, any>;\n\n/**\n * Checks if a file exists and is readable.\n * @param filePath - The file path to check for\n * @returns Ok(path) if the file exist, Error(null) if it doesn't.\n */\nexport const fileExists = async (filePath: t): ResultP<t, string> => {\n  // prettier-ignore\n  return pipeA\n    (access(filePath, fs.constants.R_OK))\n    (okReplace(filePath))\n    (errorReplace(filePath))\n    .value\n};\n\nexport async function ls(directoryPath: string): ResultP<string[], string> {\n  // prettier-ignore\n  return pipeA\n    (directoryPath)\n    (readdir)\n    (errorReplace(`${directoryPath} not found`))\n    .value\n}\n\n/**\n * Wrap a JSON parse in a\n * @returns Ok(body)\n */\nexport const parseJson = <T>(\n  data: string,\n  fileName?: string\n): Result<T, string> => {\n  try {\n    return ok(JSON.parse(data));\n  } catch (e) {\n    const message = `Couldn't parse ${fileName || \"file\"}: ${e.message}`;\n    return error(message);\n  }\n};\n\n/**\n * Recursively create a directory for a file.\n * @param filePath\n * @returns The original filePath for piping.\n */\nasync function makeDirectoryForFile(filePath: string): ResultP<string, string> {\n  // prettier-ignore\n  return pipeA\n    (filePath)\n    (path.dirname)\n    (makeDirectoryDeep)\n    (okReplace(filePath))\n    .value\n}\n\n/**\n * Read a file's contents\n * @returns a ResultP<file contents, error>\n */\nconst fsReadFile = resultify(promisify(fs.readFile));\n\nconst mkdir = resultify(promisify(fs.mkdir));\nconst writeFile = resultify(promisify(fs.writeFile));\nconst access = resultify(promisify(fs.access));\nconst unlink = resultify(promisify(fs.unlink));\nconst readdirP = promisify(fs.readdir);\nconst readdir: (path: string) => ResultP<string[], any> = resultify(\n  (path: string) => readdirP(path)\n);\n\nconst always = <T>(x: T) => (..._args: any[]) => x;\n","import * as path from \"path\";\nimport * as AlternatePattern from \"./AlternatePattern\";\n\nimport * as File from \"./File\";\nimport {\n  okChainAsync,\n  ResultP,\n  isOk,\n  okChain,\n  errorThen,\n  ok,\n  error,\n  either,\n  okThen,\n  errorRescueAsync\n} from \"result-async\";\nimport { pipeA } from \"pipeout\";\nimport { map, toPairs, flatten, compact } from \"./utils\";\nimport { AlternateFileNotFoundError } from \"./AlternateFileNotFoundError\";\n\n/**\n * the data type for a .projections.json file.\n */\nexport interface Projections {\n  [sourcePattern: string]: SourceData;\n}\n\nexport interface SourceData {\n  alternate?: string | string[];\n}\n\ntype ProjectionPair = [string, SourceData];\ntype SingleProjectionPair = [string, { alternate: string }];\n\nexport const projectionsFilename = \".projections.json\";\nconst starRegex = /\\*/;\nconst basenameRegex = /\\{\\}|\\{basename\\}/;\n\n/**\n * Find the path of the alternate file (if the alternate file actually exists)\n * @param userFilePath\n * @return ResultP(alternate file path, list of all attempted alternate files)\n */\nexport const findAlternateFile = async (\n  userFilePath: string\n): ResultP<string, AlternateFileNotFoundError> => {\n  const result = await findProjectionsFile(userFilePath);\n\n  if (!isOk(result)) {\n    return error({\n      message: `No ${projectionsFilename} found as a parent of ${userFilePath}`,\n      startingFile: userFilePath\n    });\n  }\n\n  const projectionsPath = result.ok;\n  const normalizedUserFilePath = path.resolve(userFilePath);\n\n  return pipeA(projectionsPath)(readProjections)(\n    okThen(projectionsToAlternatePatterns)\n  )(\n    okChainAsync(alternatePathIfExists(normalizedUserFilePath, projectionsPath))\n  ).value;\n};\n\n/**\n * Find the path of the alternate file if the alternate file actually exists, or create the file if it doesn't.\n * @param userFilePath\n * @return ResultP(alternate file path, error if no possible alternate file)\n *\n */\nexport const findOrCreateAlternateFile = async (\n  userFilePath: string\n): ResultP<string, AlternateFileNotFoundError> => {\n  const onError = async (err: AlternateFileNotFoundError) => {\n    const alternatesAttempted = err.alternatesAttempted || [];\n    if (alternatesAttempted.length === 0) {\n      return error({\n        ...err,\n        message: `Couldn't create an alternate file for '${userFilePath}': it didn't match any known patterns.`\n      });\n    }\n\n    const newAlternateFile = alternatesAttempted[0];\n\n    return either(\n      await File.makeFile(newAlternateFile),\n      always(ok(newAlternateFile)),\n      always(\n        error({\n          ...err,\n          message: `Couldn't create file ${newAlternateFile}`\n        })\n      )\n    );\n  };\n\n  // prettier-ignore\n  return pipeA\n    (userFilePath)\n    (findAlternateFile)\n    (errorRescueAsync(onError))\n    .value\n};\n\n/**\n * Parse the projections file into alternate pattern lookup objects.\n * @param projections\n */\nexport const projectionsToAlternatePatterns = (\n  projections: Projections\n): AlternatePattern.t[] => {\n  const pairs = toPairs(projections) as ProjectionPair[];\n  const allPairs = flatten(pairs.map(splitOutAlternates));\n\n  return allPairs.map(projectionPairToAlternatePattern);\n};\n\nexport const create = () => {};\n\nexport const findProjectionsFile = async (userFilePath: string) =>\n  File.findFileFrom(projectionsFilename)(userFilePath);\n\n/**\n * Read and parse the projections file.\n * @param userFilePath\n * @returns projections data\n */\nexport const readProjections = async (\n  projectionsPath: string\n): ResultP<Projections, AlternateFileNotFoundError> => {\n  // prettier-ignore\n  return pipeA\n    (projectionsPath)\n    (File.readFile)\n    (okThen((data: string): string => (data === \"\" ? \"{}\" : data)))\n    (okChain((x: string) => File.parseJson<Projections>(x, projectionsPath)))\n    (errorThen((err: string) => ({\n      startingFile: projectionsPath,\n      message: err\n    })))\n    .value\n};\n\nconst splitOutAlternates = (pair: ProjectionPair): SingleProjectionPair[] => {\n  const [main, { alternate }] = pair;\n\n  if (Array.isArray(alternate)) {\n    return alternate.map(\n      foo => [main, { alternate: foo }] as SingleProjectionPair\n    );\n  }\n\n  if (alternate) {\n    return [[main, { alternate }]] as SingleProjectionPair[];\n  }\n\n  throw new Error(`${main} is missing the alternate key`);\n};\n\n/**\n * Go from alternate patterns to an alternate file path (if the file exists).\n * @param userFilePath - A file path to find an alternate file for.\n * @param patterns - Alternate Patterns from a projections file.\n */\nconst alternatePathIfExists = (\n  userFilePath: string,\n  projectionsPath: string\n) => (\n  patterns: AlternatePattern.t[]\n): ResultP<string, AlternateFileNotFoundError> => {\n  const possibleAlternatePaths = map(\n    AlternatePattern.alternatePath(userFilePath, projectionsPath)\n  );\n  const removeFailedLookups = (paths: (string | null)[]): string[] =>\n    compact(paths);\n\n  // prettier-ignore\n  return pipeA\n    (patterns)\n    (possibleAlternatePaths)\n    (removeFailedLookups)\n    (File.findExisting)\n    (errorThen((alternatesAttempted: string[]) => ({\n      alternatesAttempted,\n      message: `No alternate found for ${userFilePath}. Tried: ${alternatesAttempted}`,\n      startingFile: userFilePath\n    })))\n    .value\n};\n\nconst projectionPairToAlternatePattern = ([\n  main,\n  { alternate }\n]: SingleProjectionPair): AlternatePattern.t => ({\n  main: mainPathToAlternate(main),\n  alternate: alternatePathToAlternate(alternate)\n});\n\nconst mainPathToAlternate = (path: string): string => {\n  if (!starRegex.test(path)) {\n    throw new Error(`${path} is an invalid main projection path`);\n  }\n\n  const taggedPath = /\\*\\*/.test(path) ? path : path.replace(\"*\", \"**/*\");\n\n  return taggedPath.replace(/\\*\\*/g, \"{dirname}\").replace(\"*\", \"{basename}\");\n};\n\nconst alternatePathToAlternate = (path: string): string => {\n  if (!basenameRegex.test(path)) {\n    throw new Error(`${path} is an invalid alternate projection path`);\n  }\n\n  return path.replace(/\\{\\}/g, \"{dirname}/{basename}\");\n};\n\nconst always = <T>(x: T) => (): T => x;\n","/**\n * A standardized error type for failures to find alternate files.\n */\nexport interface AlternateFileNotFoundError {\n  message: string;\n  startingFile: string;\n  alternatesAttempted?: string[];\n}\n\nexport const isAlternateFileNotFoundError = (\n  error: AlternateFileNotFoundError | any\n): error is AlternateFileNotFoundError => error.message !== undefined;\n","import * as path from \"path\";\nimport {\n  isOk,\n  okThen,\n  error,\n  errorReplace,\n  ResultP,\n  okChainAsync\n} from \"result-async\";\nimport { pipeA } from \"pipeout\";\n\nimport { fileExists, readFile, makeFile, ls } from \"./File\";\nimport { map, titleCase } from \"./utils\";\nimport { projectionsFilename } from \"./Projections\";\n\nconst sampleProjectionsDirectory = path.resolve(\n  __dirname,\n  \"../sample-projections\"\n);\n\n/**\n * Create a .projections.json file for a given directory, if it doesn't exist already.\n * @param currentPath\n * @param frameworkName - The name of the framework. If it's blank, creates a blank .projections.json.\n *                        If it's unknown, returns an error.\n * @returns The new projections file path.\n */\nexport async function initializeProjections(\n  currentPath: string,\n  frameworkName: string\n): ResultP<string, string> {\n  const projectionsPath = path.resolve(currentPath, projectionsFilename);\n\n  if (isOk(await fileExists(projectionsPath))) {\n    return error(`${projectionsPath} already exists!`);\n  }\n\n  // prettier-ignore\n  return pipeA\n    (frameworkName)\n    (sampleFileName)\n    (fileExists)\n    (errorReplace(\n      `sorry, ${frameworkName} doesn't have a default projections file yet.`\n    ))\n    (okChainAsync(readFile))\n    (okChainAsync(contents => makeFile(projectionsPath, contents)))\n    .value\n}\n\n/**\n * Get a list of known frameworks, and their human-readable names.\n * @returns a list of [name, value] pairs. Send the value to initializeProjections.\n */\nexport async function possibleFrameworks(): ResultP<\n  [string, string][],\n  string\n> {\n  // prettier-ignore\n  return pipeA\n    (sampleProjectionsDirectory)\n    (ls)\n    (okThen(map(frameworkFromSampleFilename)))\n    (okThen(frameworkNamesToTitlePair))\n    .value\n}\n\n/** Returns the absolute path to a framework file. */\nfunction sampleFileName(framework: string): string {\n  const frameworkNamePart = framework ? `.${framework}` : \"\";\n  return path.resolve(\n    sampleProjectionsDirectory,\n    `projections${frameworkNamePart}.json`\n  );\n}\n\nfunction frameworkFromSampleFilename(fileName: string): string {\n  const matches = fileName.match(/projections(?:\\.(.+))?.json/);\n\n  if (!matches) return \"\";\n\n  return matches[1] || \"\";\n}\n\nfunction frameworkNamesToTitlePair(frameworks: string[]): [string, string][] {\n  return frameworks.sort().map(framework => {\n    const name = framework ? titleCase(framework) : \"Empty\";\n    return [name, framework] as [string, string];\n  });\n}\n"],"names":["utils\r\n        .zip","path.normalize","path.dirname","path.resolve","fs.constants","fs.readFile","fs.mkdir","fs.writeFile","fs.access","fs.unlink","fs.readdir","basenameRegex","File.makeFile","always","File.findFileFrom","File.readFile","File.parseJson","AlternatePattern.alternatePath","File.findExisting"],"mappings":"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"}