import { resolve, normalize, dirname } from 'path';
import { isError, error, ok, resultify, ResultP, okReplace, errorReplace, okChainAsync, firstOk, errorThen, isOk, okThen, errorRescueAsync, okChain, either } from 'result-async';
import { readFile as readFile$1, mkdir as mkdir$1, writeFile as writeFile$1, access as access$1, unlink as unlink$1, readdir as readdir$1, constants } from 'fs';
import findUp from 'find-up';
import { promisify } from 'util';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

/**
 * Pipeable console.log
 * @param args - Varadic args to tag the log with.
 * @param data - Final data to console.log
 */
/**
 * Zip two arrays together. Output is the length of the first array.
 * @param array1
 * @param array2
 */
var zip = function (array1, array2) {
    return array1.map(function (a, i) {
        var b = array2[i];
        return [a, b];
    });
};
var map = function (f) { return function (xs) { return xs.map(f); }; };
/** Convert an object to a list of tuples. */
function toPairs(dictionary) {
    return Object.keys(dictionary).map(function (key) { return [key, dictionary[key]]; });
}
/** Shallow flatten a list. */
function flatten(xss) {
    return xss.reduce(function (acc, xs) { return acc.concat(xs); }, []);
}
function compact(xs) {
    return reject(isNil, xs);
}
function filter(f, xs) {
    return xs.reduce(function (acc, x) {
        if (!f(x))
            return acc;
        acc.push(x);
        return acc;
    }, []);
}
function reject(f, xs) {
    return filter(function (x) { return !f(x); }, xs);
}
function isNil(x) {
    return x === undefined || x === null;
}
var titleCase = function (s) {
    return s ? s.charAt(0).toUpperCase() + s.slice(1) : "";
};

var slash = "[/\\]";
var notSlash = "[^/\\]";
var escapedSlash = "[/\\\\]";
var anyBackslashRegex = /\\/g;
var escapedBackslash = "\\\\";
var transformationPattern = "{([^{}]+)}";
var dirnameRegex = new RegExp("{dirname}" + escapedSlash, "g");
var basenameRegex = /{basename}/g;
var dirnamePattern = "(?:(.+)" + slash + ")?";
var basenamePattern = "(" + notSlash + "+)";
/**
 * Given a filePath and an AlternatePath, calculate if the filePath matches
 * a pattern, and if it does, calculate what the matching alternate file path
 * would be.
 * @param path - the absolute path to the file
 * @param projectionsPath - the absolute path to the projections file
 * @param alternatePath - the AlternatePath object to match against.
 */
var alternatePath = function (path, projectionsPath) { return function (_a) {
    var main = _a.main, alternate = _a.alternate;
    return alternatePathForSide(alternate, main, path, projectionsPath) ||
        alternatePathForSide(main, alternate, path, projectionsPath);
}; };
var alternatePathForSide = function (pathPattern, alternatePattern, filePath, projectionsPath) {
    var absolutePattern = combinePaths(projectionsPath, pathPattern);
    var absoluteAlternatePattern = combinePaths(projectionsPath, alternatePattern);
    var matchResult = matchPatternToPath(absolutePattern, filePath);
    if (isError(matchResult))
        return null;
    var pathMatches = matchResult.ok;
    var transformations = patternToTransformations(absolutePattern);
    return fillPattern(transformations, pathMatches, absoluteAlternatePattern);
};
/**
 * Take the available transformation names and match values, and use them to fill up the alternate pattern.
 * @param transformations
 * @param matches
 * @param alternatePattern
 * @returns A complete file path.
 */
var fillPattern = function (transformations, matches, alternatePattern) {
    var filledPath = zip(transformations, matches)
        .reduce(function (alternatePattern, _a) {
        var transformation = _a[0], match = _a[1];
        return alternatePattern.replace("{" + transformation + "}", match || "");
    }, alternatePattern);
    return normalize(filledPath);
};
/**
 * Extract a list of transformations from a pattern, to be zipped with their matches.
 * @param pathPattern
 * @returns list of transformation names
 */
var patternToTransformations = function (pathPattern) {
    var regex = new RegExp(transformationPattern, "g");
    var transformations = [];
    var matches;
    while ((matches = regex.exec(pathPattern)) !== null) {
        transformations.push(matches[1]);
    }
    return transformations;
};
/**
 * Take a path pattern string, and use it to try to pull out matches from the file path.
 * @param pathPattern - String to be converted to regex
 * @param filePath - Current file
 * @returns Ok(matches) | Error(null) if no matches
 */
var matchPatternToPath = function (pathPattern, filePath) {
    var regex = patternToRegex(pathPattern);
    var matches = filePath.match(regex);
    if (!matches || !matches[2])
        return error(null);
    var pathMatches = matches.slice(1);
    return ok(pathMatches);
};
/**
 * Take a projections pattern, and convert it to a regex that will extract the variable parts.
 */
var patternToRegex = function (pathPattern) {
    var regexPattern = pathPattern
        .replace(dirnameRegex, dirnamePattern)
        .replace(basenameRegex, basenamePattern);
    var escapedPattern = escapeBackslashes(regexPattern);
    return new RegExp(escapedPattern);
};
/**
 * Append a pattern to the absolute path of the projections file
 * @param projectionsPath - absolute path to the projections file
 * @param filePattern -
 */
var combinePaths = function (projectionsPath, filePattern) {
    var projectionsDir = dirname(projectionsPath);
    return resolve(projectionsDir, filePattern);
};
/**
 * Escape backslashes before converting a string to a regex.
 */
var escapeBackslashes = function (pattern) {
    return pattern.replace(anyBackslashRegex, escapedBackslash);
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/**
 * Pipe a value through a series of transformers,
 * where the value can be a promise and transformers can return promises.
 * @param value - The value to send through the pipeline.
 * @returns nextPipe - Pass a transformer to pipe again. Or, use .value to get the transformed value.
 */
function pipeA(value) {
    function nextPipe(transformer) {
        return pipeA(Promise.resolve(value).then(transformer));
    }
    nextPipe.value = Promise.resolve(value);
    return nextPipe;
}

/**
 * Find a file by recursively walking up the directory chain.
 * @param fileName - The filename to look for.
 * @param fromFilePath - The file to start looking from
 * @return the full path/"not found"
 */
var findFileFrom = function (fileName) { return function (fromFilePath) { return __awaiter(void 0, void 0, ResultP, function () {
    var filePath;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, findUp(fileName, { cwd: fromFilePath })];
            case 1:
                filePath = _a.sent();
                return [2 /*return*/, filePath ? ok(filePath) : error("file not found")];
        }
    });
}); }; };
/**
 * Create a new file, with contents. Also creates the path if necessary.
 * @param path
 * @param contents
 * @returns filePath
 */
function makeFile(filePath, contents) {
    if (contents === void 0) { contents = ""; }
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            // prettier-ignore
            return [2 /*return*/, pipeA(filePath)(makeDirectoryForFile)(okChainAsync(makeFileShallow(contents)))
                    .value];
        });
    });
}
/**
 * Create a new file, with contents. Fails if the directory doesn't exist.
 * @param path
 * @param contents
 * @returns filePath
 */
var makeFileShallow = function (contents) { return function (filePath) {
    // prettier-ignore
    return pipeA(writeFile(filePath, contents, { flag: "wx" }))(errorReplace(filePath + " already exists"))(okReplace(filePath))
        .value;
}; };
function makeDirectoryDeep(dirPath) {
    return __awaiter(this, void 0, ResultP, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, mkdir(dirPath, { recursive: true })];
                case 1:
                    _a.sent();
                    return [2 /*return*/, ok(dirPath)];
            }
        });
    });
}
/**
 * Check if any of the provided files exists.
 * @param filePaths
 * @returns Ok(filePath) | Error(null)
 */
var findExisting = function (filePaths) { return __awaiter(void 0, void 0, ResultP, function () {
    return __generator(this, function (_a) {
        // prettier-ignore
        return [2 /*return*/, pipeA(filePaths)(map(fileExists))(function (files) { return Promise.all(files); })(function (file) { return firstOk(file); })(errorThen(always(filePaths)))
                .value];
    });
}); };
/**
 * Read the contents of a file.
 */
var readFile = function (path) {
    return fsReadFile(path, "utf8");
};
/**
 * Checks if a file exists and is readable.
 * @param filePath - The file path to check for
 * @returns Ok(path) if the file exist, Error(null) if it doesn't.
 */
var fileExists = function (filePath) { return __awaiter(void 0, void 0, ResultP, function () {
    return __generator(this, function (_a) {
        // prettier-ignore
        return [2 /*return*/, pipeA(access(filePath, constants.R_OK))(okReplace(filePath))(errorReplace(filePath))
                .value];
    });
}); };
function ls(directoryPath) {
    return __awaiter(this, void 0, ResultP, function () {
        return __generator(this, function (_a) {
            // prettier-ignore
            return [2 /*return*/, pipeA(directoryPath)(readdir)(errorReplace(directoryPath + " not found"))
                    .value];
        });
    });
}
/**
 * Wrap a JSON parse in a
 * @returns Ok(body)
 */
var parseJson = function (data, fileName) {
    try {
        return ok(JSON.parse(data));
    }
    catch (e) {
        var message = "Couldn't parse " + (fileName || "file") + ": " + e.message;
        return error(message);
    }
};
/**
 * Recursively create a directory for a file.
 * @param filePath
 * @returns The original filePath for piping.
 */
function makeDirectoryForFile(filePath) {
    return __awaiter(this, void 0, ResultP, function () {
        return __generator(this, function (_a) {
            // prettier-ignore
            return [2 /*return*/, pipeA(filePath)(dirname)(makeDirectoryDeep)(okReplace(filePath))
                    .value];
        });
    });
}
/**
 * Read a file's contents
 * @returns a ResultP<file contents, error>
 */
var fsReadFile = resultify(promisify(readFile$1));
var mkdir = resultify(promisify(mkdir$1));
var writeFile = resultify(promisify(writeFile$1));
var access = resultify(promisify(access$1));
var unlink = resultify(promisify(unlink$1));
var readdirP = promisify(readdir$1);
var readdir = resultify(function (path) { return readdirP(path); });
var always = function (x) { return function () {
    var _args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        _args[_i] = arguments[_i];
    }
    return x;
}; };

var projectionsFilename = ".projections.json";
var starRegex = /\*/;
var basenameRegex$1 = /\{\}|\{basename\}/;
/**
 * Find the path of the alternate file (if the alternate file actually exists)
 * @param userFilePath
 * @return ResultP(alternate file path, list of all attempted alternate files)
 */
var findAlternateFile = function (userFilePath) { return __awaiter(void 0, void 0, ResultP, function () {
    var result, projectionsPath, normalizedUserFilePath;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, findProjectionsFile(userFilePath)];
            case 1:
                result = _a.sent();
                if (!isOk(result)) {
                    return [2 /*return*/, error({
                            message: "No " + projectionsFilename + " found as a parent of " + userFilePath,
                            startingFile: userFilePath
                        })];
                }
                projectionsPath = result.ok;
                normalizedUserFilePath = resolve(userFilePath);
                return [2 /*return*/, pipeA(projectionsPath)(readProjections)(okThen(projectionsToAlternatePatterns))(okChainAsync(alternatePathIfExists(normalizedUserFilePath, projectionsPath))).value];
        }
    });
}); };
/**
 * Find the path of the alternate file if the alternate file actually exists, or create the file if it doesn't.
 * @param userFilePath
 * @return ResultP(alternate file path, error if no possible alternate file)
 *
 */
var findOrCreateAlternateFile = function (userFilePath) { return __awaiter(void 0, void 0, ResultP, function () {
    var onError;
    return __generator(this, function (_a) {
        onError = function (err) { return __awaiter(void 0, void 0, void 0, function () {
            var alternatesAttempted, newAlternateFile, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        alternatesAttempted = err.alternatesAttempted || [];
                        if (alternatesAttempted.length === 0) {
                            return [2 /*return*/, error(__assign(__assign({}, err), { message: "Couldn't create an alternate file for '" + userFilePath + "': it didn't match any known patterns." }))];
                        }
                        newAlternateFile = alternatesAttempted[0];
                        _a = either;
                        return [4 /*yield*/, makeFile(newAlternateFile)];
                    case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent(),
                            always$1(ok(newAlternateFile)),
                            always$1(error(__assign(__assign({}, err), { message: "Couldn't create file " + newAlternateFile })))])];
                }
            });
        }); };
        // prettier-ignore
        return [2 /*return*/, pipeA(userFilePath)(findAlternateFile)(errorRescueAsync(onError))
                .value];
    });
}); };
/**
 * Parse the projections file into alternate pattern lookup objects.
 * @param projections
 */
var projectionsToAlternatePatterns = function (projections) {
    var pairs = toPairs(projections);
    var allPairs = flatten(pairs.map(splitOutAlternates));
    return allPairs.map(projectionPairToAlternatePattern);
};
var findProjectionsFile = function (userFilePath) { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {
    return [2 /*return*/, findFileFrom(projectionsFilename)(userFilePath)];
}); }); };
/**
 * Read and parse the projections file.
 * @param userFilePath
 * @returns projections data
 */
var readProjections = function (projectionsPath) { return __awaiter(void 0, void 0, ResultP, function () {
    return __generator(this, function (_a) {
        // prettier-ignore
        return [2 /*return*/, pipeA(projectionsPath)(readFile)(okThen(function (data) { return (data === "" ? "{}" : data); }))(okChain(function (x) { return parseJson(x, projectionsPath); }))(errorThen(function (err) { return ({
                startingFile: projectionsPath,
                message: err
            }); }))
                .value];
    });
}); };
var splitOutAlternates = function (pair) {
    var main = pair[0], alternate = pair[1].alternate;
    if (Array.isArray(alternate)) {
        return alternate.map(function (foo) { return [main, { alternate: foo }]; });
    }
    if (alternate) {
        return [[main, { alternate: alternate }]];
    }
    throw new Error(main + " is missing the alternate key");
};
/**
 * Go from alternate patterns to an alternate file path (if the file exists).
 * @param userFilePath - A file path to find an alternate file for.
 * @param patterns - Alternate Patterns from a projections file.
 */
var alternatePathIfExists = function (userFilePath, projectionsPath) { return function (patterns) {
    var possibleAlternatePaths = map(alternatePath(userFilePath, projectionsPath));
    var removeFailedLookups = function (paths) {
        return compact(paths);
    };
    // prettier-ignore
    return pipeA(patterns)(possibleAlternatePaths)(removeFailedLookups)(findExisting)(errorThen(function (alternatesAttempted) { return ({
        alternatesAttempted: alternatesAttempted,
        message: "No alternate found for " + userFilePath + ". Tried: " + alternatesAttempted,
        startingFile: userFilePath
    }); }))
        .value;
}; };
var projectionPairToAlternatePattern = function (_a) {
    var main = _a[0], alternate = _a[1].alternate;
    return ({
        main: mainPathToAlternate(main),
        alternate: alternatePathToAlternate(alternate)
    });
};
var mainPathToAlternate = function (path) {
    if (!starRegex.test(path)) {
        throw new Error(path + " is an invalid main projection path");
    }
    var taggedPath = /\*\*/.test(path) ? path : path.replace("*", "**/*");
    return taggedPath.replace(/\*\*/g, "{dirname}").replace("*", "{basename}");
};
var alternatePathToAlternate = function (path) {
    if (!basenameRegex$1.test(path)) {
        throw new Error(path + " is an invalid alternate projection path");
    }
    return path.replace(/\{\}/g, "{dirname}/{basename}");
};
var always$1 = function (x) { return function () { return x; }; };

var isAlternateFileNotFoundError = function (error) { return error.message !== undefined; };

var sampleProjectionsDirectory = resolve(__dirname, "../sample-projections");
/**
 * Create a .projections.json file for a given directory, if it doesn't exist already.
 * @param currentPath
 * @param frameworkName - The name of the framework. If it's blank, creates a blank .projections.json.
 *                        If it's unknown, returns an error.
 * @returns The new projections file path.
 */
function initializeProjections(currentPath, frameworkName) {
    return __awaiter(this, void 0, ResultP, function () {
        var projectionsPath, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    projectionsPath = resolve(currentPath, projectionsFilename);
                    _a = isOk;
                    return [4 /*yield*/, fileExists(projectionsPath)];
                case 1:
                    if (_a.apply(void 0, [_b.sent()])) {
                        return [2 /*return*/, error(projectionsPath + " already exists!")];
                    }
                    // prettier-ignore
                    return [2 /*return*/, pipeA(frameworkName)(sampleFileName)(fileExists)(errorReplace("sorry, " + frameworkName + " doesn't have a default projections file yet."))(okChainAsync(readFile))(okChainAsync(function (contents) { return makeFile(projectionsPath, contents); }))
                            .value];
            }
        });
    });
}
/**
 * Get a list of known frameworks, and their human-readable names.
 * @returns a list of [name, value] pairs. Send the value to initializeProjections.
 */
function possibleFrameworks() {
    return __awaiter(this, void 0, ResultP, function () {
        return __generator(this, function (_a) {
            // prettier-ignore
            return [2 /*return*/, pipeA(sampleProjectionsDirectory)(ls)(okThen(map(frameworkFromSampleFilename)))(okThen(frameworkNamesToTitlePair))
                    .value];
        });
    });
}
/** Returns the absolute path to a framework file. */
function sampleFileName(framework) {
    var frameworkNamePart = framework ? "." + framework : "";
    return resolve(sampleProjectionsDirectory, "projections" + frameworkNamePart + ".json");
}
function frameworkFromSampleFilename(fileName) {
    var matches = fileName.match(/projections(?:\.(.+))?.json/);
    if (!matches)
        return "";
    return matches[1] || "";
}
function frameworkNamesToTitlePair(frameworks) {
    return frameworks.sort().map(function (framework) {
        var name = framework ? titleCase(framework) : "Empty";
        return [name, framework];
    });
}

export { findAlternateFile, findOrCreateAlternateFile, initializeProjections, isAlternateFileNotFoundError, possibleFrameworks };
//# sourceMappingURL=alternate-file.js.map
